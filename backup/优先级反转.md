# 优先级反转问题说明

## 1. 概述
优先级反转（Priority Inversion）指在抢占式调度系统中，高优先级任务被间接阻塞而让低优先级任务先执行。例如：低优先级任务持有互斥锁，随后高优先级任务到来需要该锁而被阻塞，此时一个与锁无关的中优先级任务不断运行，把低优先级任务挤出 CPU，导致高优先级任务长时间得不到执行。1997 年的火星探路者曾因未启用优先级继承而频繁软件重启，这是该问题的经典案例。

## 2. 典型场景
1. 低优先级任务 `L` 进入临界区，持有互斥锁 `mutex`。
2. 高优先级任务 `H` 需要同一锁，阻塞在 `mutex` 上。
3. 中优先级任务 `M` 周期性运行且与锁无关，但因为优先级比 `L` 高，会不断抢占 CPU。
4. 结果：`L` 无法继续运行并释放锁，`H` 间接被 `M` 阻塞，形成优先级反转。

简化示例：
```c
// 三个任务：H > M > L
void low_task(void) {
    lock(mutex);
    do_slow_io();      // 临界区内的阻塞/I-O 放大风险
    unlock(mutex);
}

void high_task(void) { // 需要低任务持锁的资源
    lock(mutex);
    critical_work();
    unlock(mutex);
}
```

## 3. 表现与风险
- 高优先级任务响应时间不可预测，实时截止期可能违约。
- 系统吞吐下降，出现“软死锁”体验：任务未死锁，但迟迟得不到 CPU。
- 故障复现困难：堆栈通常停在高优先级任务等待锁，根因在低优先级临界区和中优先级抢占。

## 4. 常见诱因
- 临界区过大，包含 I/O、sleep、内存分配或复杂计算。
- 把频繁路径放到大粒度锁里，缺少锁超时或等待监控。
- 任务优先级设计脱节，资源访问顺序没有审计，嵌套锁导致持锁时间不可控。

## 5. 解决与缓解策略
- **优先级继承（PI）**：低优先级任务在持锁期间临时提升到被阻塞任务的最高优先级，释放锁后恢复。适用于互斥锁，Linux futex PI、FreeRTOS mutex 等均支持。
- **优先级上限协议（PCP）**：为资源设置上限优先级，任何任务进入临界区时直接提升到该上限，防止中优先级插队并避免循环等待。
- **缩短临界区**：把 I/O、sleep、动态分配移出锁内；拆分大锁为细粒度锁；必要时使用无锁结构（环形缓冲、CAS）。
- **调度隔离与抢占阈值**：关键高优先级任务单独绑核或提高抢占阈值，减少被无关中优先级任务抢占。
- **访问顺序规范**：定义全局资源获取顺序，避免反向加锁；必要时对嵌套锁做静态分析。

## 6. 工程实践与调试
- **选对锁原语**：实时路径默认使用带 PI 的互斥锁；避免用信号量模拟互斥。
- **监控锁等待**：记录持锁/等待时长、等待次数，超过阈值打点日志；采样调用栈定位谁持锁、谁在等。
- **测试构造**：并发运行高/中/低优先级任务争用同一资源，施加 I/O 和延迟，测量高优先级任务的最长阻塞时间。
- **代码审查要点**：检查锁内是否有阻塞/耗时操作；确认资源访问顺序与优先级设计一致；必要时为实时任务提供无锁读路径或双缓冲。

## 7. 经典案例：1997 火星探路者
背景：火星探路者使用 VxWorks 实时操作系统。着陆后数天，飞行软件偶发重启。原因是优先级反转未启用优先级继承，触发看门狗导致系统复位。

关键任务与优先级（简化）：
- 高优先级：总线管理/通信调度任务（需要共享总线互斥锁）。
- 中优先级：通信中继或数据处理任务（与锁无关，运行时间较长）。
- 低优先级：气象数据处理任务（持有总线互斥锁，做传感器读写）。

事件链：
1. 低优先级气象任务获取总线互斥锁，开始处理。
2. 高优先级总线管理任务到来，尝试获取同一互斥锁，被阻塞。
3. 中优先级通信/数据处理任务开始运行，因优先级高于低任务且不依赖互斥锁，持续抢占 CPU。
4. 低优先级任务无法继续执行，锁无法释放，高优先级任务一直等待。
5. 高优先级任务超时未完成，触发看门狗，系统发生软件重启。

解决方案：
- VxWorks 互斥锁默认关闭优先级继承，团队在地面通过远程命令开启互斥锁的优先级继承属性，低优先级任务在持锁期间提升优先级，得以及时释放锁，问题消失。
- 这是首次在深空探测任务中通过软件配置修复优先级反转的著名案例，强调了实时系统中互斥锁 PI 的必要性。

经验教训：
- 实时任务的互斥锁应默认开启 PI/PCP，尤其在看门狗、截止期敏感路径。
- 持锁区不得放置长 I/O；中优先级高负载任务可能放大问题。
- 出现间歇性重启或延迟抖动时，需检查高优先级任务是否等待低优先级持锁资源。

## 7. 快速检查清单
- 高优先级路径的临界区是否只包含必要的快速操作？
- 持锁期间是否可能触发 I/O、sleep、内存分配或跨线程同步？
- 互斥锁是否开启了优先级继承/上限，是否有等待监控与超时？
- 是否定义了统一的资源获取顺序，避免嵌套锁反向请求？
- 是否对高/中/低优先级争用场景做过压力测试并记录阻塞上界？
